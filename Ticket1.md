## 1 Формализация понятия алгоитма. Анализ сложности и эффективности алгоритма.

**Алгоритм** - совокупность точно заданных действий для выполнения некоторого класса задач или набора инструкций, описывающих порядок действий исполнителя.

Сложность алгоритмов обычно оценивают по времени выполнения или по используемой памяти. В обоих случаях сложность зависит от размеров входных данных: массив из 100 элементов будет обработан быстрее, чем аналогичный из 1000. При этом точное время мало кого интересует: оно зависит от процессора, типа данных, языка программирования и множества других параметров. Важна лишь асимптотическая сложность, т. е. сложность при стремлении размера входных данных к бесконечности.

**O()** - логарифмическая вычислительная сложность.

### Например:

- **O(n)** - линейная сложность
  Такой сложностью обладает, например, алгоритм поиска наибольшего элемента в не отсортированном массиве. Нам придётся пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.
- **O(logn)** - логарифмическая сложность
  Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить пополам, в итоге проверим log n элементов.
- **O(n2)** — квадратичная сложность
  Такую сложность имеет, например, алгоритм сортировки вставками. В канонической реализации он представляет из себя два вложенных цикла: один, чтобы проходить по всему массиву, а второй, чтобы находить место очередному элементу в уже отсортированной части. Таким образом, количество операций будет зависеть от размера массива как n * n, т. е. n2.

Бывают и другие оценки по сложности, но все они основаны на том же принципе.

Также случается, что время работы алгоритма вообще не зависит от размера входных данных. Тогда сложность обозначают как O(1). Например, для определения значения третьего элемента массива не нужно ни запоминать элементы, ни проходить по ним сколько-то раз. Всегда нужно просто дождаться в потоке входных данных третий элемент и это будет результатом, на вычисление которого для любого количества данных нужно одно и то же время.

Аналогично проводят оценку и по памяти, когда это важно. Однако алгоритмы могут использовать значительно больше памяти при увеличении размера входных данных, чем другие, но зато работать быстрее. И наоборот. Это помогает выбирать оптимальные пути решения задач исходя из текущих условий и требований.

## 2 Понятие разряженных матриц. Матрица со случайным расположением эллементов.

**Разрежённая матрица** — двухмерный массив, большинство элементов которого равны между собой, так что хранить в памяти достаточно лишь небольшое число значений отличных от основного (фонового) значения остальных элементов.

### Различают два типа разреженных матриц:

1. матрицы, в которых местоположения элементов со значениями, отличными от фонового, могут быть математически описаны
2. матрицы со случайным расположением элементов.

**Матрицы со случайным расположением элементов** - это матрица, у которой местоположение элементов со значениями, отличными от фонового, не могут быть математически описаны, то есть в их расположении нет какой-либо закономерности.

### Пример матрицы размерности 3x3 со случайным расположением элементов:

| 3 | 1 | 0 |
| 0 | 0 | 9 |
| 0 | 8 | 0 |

Один из основных способов хранения подобных разреженных матриц заключается в запоминании ненулевых элементов в одномерном массиве записей с идентификацией каждого элемента массива индексами строки и столбца матрицы. Такой способ хранения называется последовательным представлением разреженных матриц.

| ROW | COLUMN | VALUE |
| :-: | :----: | :---: |
| 1   | 1      | 3     |
| 1   | 2      | 1     |
| 2   | 3      | 9     |
| 3   | 2      | 8     |

Доступ к элементу матрицы A с индексами i и j выполняется выборкой индекса i из поля ROW, индекса j из поля COLUMN и значения элемента из поля VALUE. Следует отметить, что элементы матрицы обязательно запоминаются в порядке возрастания номеров строк для ускорения поиска.

Такое представление матрицы A сокращает используемый объем памяти. Для больших матриц экономия памяти является очень актуальной проблемой.